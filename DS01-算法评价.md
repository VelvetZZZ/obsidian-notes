*判断题* *3 多选题 19

# 判断题

## 1-1 **NlogN² 和 NlogN 具有相同的<span style="background:#fdbfff">增长速度</span>。** T
#### **渐进时间复杂度增长速度对比**
我们来看两个函数：

-  f(n) = N log N 

-  g(n) = N log N^2 

我们可以先进行数学化简：

$$

\log N^2 = 2 \log N

$$

因此：

$$

g(n) = N \cdot \log N^2 = N \cdot 2\log N = 2N\log N

$$

可以看出：

  

$$

f(n) = N\log N,\quad g(n) = 2N\log N

$$

二者在渐进意义上具有相同的增长速度，  

都属于同一复杂度阶：

$$

\Theta(N \log N)

$$
常数因子 \( 2 \) 在大 O 表示中会被忽略。
#### 渐进时间复杂度
> **渐进时间复杂度（Asymptotic Time Complexity）**：
> 是用来衡量 **当输入规模** n **趋近于无穷大时**，
> **算法运行时间随** n **的增长趋势**。

-  **记忆口诀：
> <font color="#8064a2">“看大不看小，取快不取慢，常数当空气，低阶要忽略。”</font>
- 解读： 
| 看大不看小 | 只关心当 $n$ 很大时的表现 
| 取快不取慢 | 比较的是哪个增长得更快 
| 常数当空气 | 常数倍数在比较中可以忽略 
| 低阶要忽略 | 低阶项对增长趋势影响很小，也忽略 
-  速度快慢快速口诀记忆法
> <font color="#8064a2">口诀：常 对 线 线方 方立 指 阶</font>
- 意思是：
```

O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)

```
#####  常见时间复杂度从快到慢排序表

| 排名 | 渐进时间复杂度 | 名称 | 举例算法 |

|------|------------------|------------|----------------------------|

| ① | `O(1)` | 常数级 | 哈希表查找、直接访问 |

| ② | `O(log n)` | 对数级 | 二分查找、AVL 树查找 |

| ③ | `O(n)` | 线性级 | 顺序查找、遍历数组 |

| ④ | `O(n log n)` | 线性对数级 | 快速排序、归并排序、堆排序 |

| ⑤ | `O(n²)` | 平方级 | 冒泡排序、插入排序 |

| ⑥ | `O(n³)` | 立方级 | 三重循环、Floyd算法 |

| ⑦ | `O(2ⁿ)` | 指数级 | 回溯法、子集生成 |

| ⑧ | `O(n!)` | 阶乘级 | 全排列、旅行商问题 |

##### 🔍 判断谁更快的技巧

1. 比较主项的“增长率”大小

2. 忽略常数因子和低阶项

3. 指数、阶乘是最慢的，能避免尽量避免！

---

###### ✨ 图像理解（增长趋势）

随着 `n` 的增大：

```

O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)

```

---

###### 应试小练习


1. `O(n log n)` vs `O(n²)` → ✅ `O(n log n)` 更快

2. `O(2ⁿ)` vs `O(n!)` → ✅ `O(2ⁿ)` 更快

3. `O(1)` vs `O(log n)` → ✅ `O(1)` 更快

---
> 记住：**渐进复杂度是“长期跑步谁更慢”的比较！**
---

## 1-2 对于某些算法，随着问题规模的扩大，所花的时间不一定<span style="background:#fdbfff">单调增加</span>。T
#### **<font color="#c0504d"> 对算法运行时间随输入规模增长变化趋势的理解</font>**
##### 大多数时候我们说“输入规模越大，运行时间越长”——这说的是**渐进意义上的时间复杂度**。但在**实际运行中**，**时间并不总是单调递增**，原因包括：

> **1.** 某些输入会触发更快的路径
> 例如：快速排序（Quick Sort）在某些特殊输入下比其他情况运行得更快或更慢；或者算法中有某种优化，例如提前终止（early stopping）。
> **2.** 缓存优化、内存对齐等系统层面影响
> 当数据量增大但正好被缓存优化、命中CPU cache，反而运行时间会降低。
> **3.** 分支选择不同，导致执行路径变化
> 输入不同会导致程序选择不同的分支，比如循环提前跳出、条件判断不满足等、运行时间差异很大。
> **4.** 最欢情况 **≠** 实际情况
> - 例如二分查找的最坏情况是 O(\log n)，但某些情况一开始就找到目标，实际只用了 1 步。
##### **结论总结：**
- **“非单调”= 时间曲线可能会上下起伏。**
- “算法实际运行时间 ≠ 理论时间复杂度（渐进上界）”
- <font color="#8064a2">渐进时间复杂度是对**最坏情况的估计**。</font>
- 实际运行中，**不一定输入变大就花更多时间**。
- 所以这道题说“**不一定单调增加**”是对的。