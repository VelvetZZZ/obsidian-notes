#算法 #时间复杂度 #C语言 #数据结构基础

*判断题* *3 多选题 19

# 判断题

### 1-1 **NlogN² 和 NlogN 具有相同的<span style="background:#fdbfff">增长速度</span>。** T
##### **渐进时间复杂度增长速度对比**
我们来看两个函数：

-  f(n) = N log N 

-  g(n) = N log N^2 

我们可以先进行数学化简：

$$

\log N^2 = 2 \log N

$$

因此：

$$

g(n) = N \cdot \log N^2 = N \cdot 2\log N = 2N\log N

$$

可以看出：

  

$$

f(n) = N\log N,\quad g(n) = 2N\log N

$$

二者在渐进意义上具有相同的增长速度，  

都属于同一复杂度阶：

$$

\Theta(N \log N)

$$
常数因子 \( 2 \) 在大 O 表示中会被忽略。
##### 渐进时间复杂度
> **渐进时间复杂度（Asymptotic Time Complexity）**：
> 是用来衡量 **当输入规模** n **趋近于无穷大时**，
> **算法运行时间随** n **的增长趋势**。

-  **记忆口诀：
> <font color="#8064a2">“看大不看小，取快不取慢，常数当空气，低阶要忽略。”</font>
- 解读： 
| 看大不看小 | 只关心当 $n$ 很大时的表现 
| 取快不取慢 | 比较的是哪个增长得更快 
| 常数当空气 | 常数倍数在比较中可以忽略 
| 低阶要忽略 | 低阶项对增长趋势影响很小，也忽略 
-  速度快慢快速口诀记忆法
> <font color="#8064a2">口诀：常 对 线 线方 方立 指 阶</font>
- 意思是：
```

O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)

```
######  常见时间复杂度从快到慢排序表

| 排名 | 渐进时间复杂度 | 名称 | 举例算法 |

|------|------------------|------------|----------------------------|

| ① | `O(1)` | 常数级 | 哈希表查找、直接访问 |

| ② | `O(log n)` | 对数级 | 二分查找、AVL 树查找 |

| ③ | `O(n)` | 线性级 | 顺序查找、遍历数组 |

| ④ | `O(n log n)` | 线性对数级 | 快速排序、归并排序、堆排序 |

| ⑤ | `O(n²)` | 平方级 | 冒泡排序、插入排序 |

| ⑥ | `O(n³)` | 立方级 | 三重循环、Floyd算法 |

| ⑦ | `O(2ⁿ)` | 指数级 | 回溯法、子集生成 |

| ⑧ | `O(n!)` | 阶乘级 | 全排列、旅行商问题 |

###### 🔍 判断谁更快的技巧

1. 比较主项的“增长率”大小

2. 忽略常数因子和低阶项

3. 指数、阶乘是最慢的，能避免尽量避免！

---

###### ✨ 图像理解（增长趋势）

随着 `n` 的增大：

```

O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)

```

---

###### 应试小练习


1. `O(n log n)` vs `O(n²)` → ✅ `O(n log n)` 更快

2. `O(2ⁿ)` vs `O(n!)` → ✅ `O(2ⁿ)` 更快

3. `O(1)` vs `O(log n)` → ✅ `O(1)` 更快

---
> 记住：**渐进复杂度是“长期跑步谁更慢”的比较！**
---

### 1-3 对于某些算法，随着问题规模的扩大，所花的时间不一定<span style="background:#fdbfff">单调增加</span>。T
##### **<font color="#c0504d"> 对算法运行时间随输入规模增长变化趋势的理解</font>**
###### 大多数时候我们说“输入规模越大，运行时间越长”——这说的是**渐进意义上的时间复杂度**。但在**实际运行中**，**时间并不总是单调递增**，原因包括：

> **1.** 某些输入会触发更快的路径
> 例如：快速排序（Quick Sort）在某些特殊输入下比其他情况运行得更快或更慢；或者算法中有某种优化，例如提前终止（early stopping）。
> **2.** 缓存优化、内存对齐等系统层面影响
> 当数据量增大但正好被缓存优化、命中CPU cache，反而运行时间会降低。
> **3.** 分支选择不同，导致执行路径变化
> 输入不同会导致程序选择不同的分支，比如循环提前跳出、条件判断不满足等、运行时间差异很大。
> **4.** 最欢情况 **≠** 实际情况
> - 例如二分查找的最坏情况是 O(\log n)，但某些情况一开始就找到目标，实际只用了 1 步。
###### **结论总结：**
- **“非单调”= 时间曲线可能会上下起伏。**
- “算法实际运行时间 ≠ 理论时间复杂度（渐进上界）”
- <font color="#8064a2">渐进时间复杂度是对**最坏情况的估计**。</font>
- 实际运行中，**不一定输入变大就花更多时间**。
- 所以这道题说“**不一定单调增加**”是对的。


### 1-6 Let n be a non-negative integer representing the size of input. The time complexity of the following piece of code is O(n).      T

- 设 n 是一个**非负整数**，表示**输入的规模**，- 下面这段代码的时间复杂度是 O(n)   ✅
```
int func(int n){
    int sum = 0;
        for(int i = n; i > 0; i /= 2)
            for(int j = 0; j < i; j++)
                sum++;
    return sum;
}

```

##### <span style="background:rgba(92, 92, 92, 0.2)">本题解析</span>
######  1. 拆解循环

- **外层循环：** `for(int i = n; i > 0; i /= 2)`
    
    - `i` 的值**不是** $n, n-1, n-2, \dots$
        
    - `i` 的值是 $n, n/2, n/4, n/8, \dots, 1$ (每次都减半)
        
    - 这是一个 **$O(\log n)$** 次的循环。
        
- **内层循环：** `for(int j = 0; j < i; j++)`
    
    - 它每次执行 **`i`** 次。
        

###### 2. 核心：求和 (Summing the Work)

`sum++` 的总执行次数 $T(n)$ 是**每一次**内循环执行次数的总和：

- 外层 `i = n` 时， 内层执行 **$n$** 次
    
- 外层 `i = n/2` 时， 内层执行 **$n/2$** 次
    
- 外层 `i = n/4` 时， 内层执行 **$n/4$** 次
    
- ...
    
- 外层 `i = 1` 时， 内层执行 **$1$** 次
    

所以，总执行次数 $T(n) = n + \frac{n}{2} + \frac{n}{4} + \frac{n}{8} + \dots + 1$

###### 3. 计算总和

这是一个等比数列求和 (Geometric Series)。

$T(n) = n + \frac{n}{2} + \frac{n}{4} + \dots + 1$

我们把这个数列反过来写：

$T(n) = 1 + 2 + 4 + 8 + \dots + \frac{n}{2} + n$

根据等比数列求和公式，这个和约等于最后一项 $n$ 的两倍，即 $2n - 1$。

（你也可以把 $n$ 提出来：$T(n) = n \times (1 + \frac{1}{2} + \frac{1}{4} + \dots)$，括号内的和无限趋近于 2）

所以，总执行次数 $T(n) \approx 2n$。

###### 本题型：减半 + 遍历

for (i = n; i > 0; i /= 2)

    for (j = 0; j < i; j++)  → O(n)
#### <font color="#c0504d">分析“变动内循环”的时间复杂度</font>

#一、基础循环复杂度模式表

| 代码结构                        | 时间复杂度    | 快速识别  | 具体含义                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| --------------------------- | -------- | ----- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| for (i = 0; i < n; i++)     | O(n)     | 线性增长  | 变量 `i` 从 0 开始，每次加 1，一直加到 $n-1$ (因为 $i < n$)                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| for (i = 0; i < n; i+=k)    | O(n)     | 步长为常数 | 变量 `i` 从 0 开始，每次加 `k` (比如 0, 3, 6, 9...)，直到 `i` 不再小于 $n$。                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| for(i = n; i > 0; i--)      | O(n)     | 倒序遍历  | 变量 `i` 从 $n$ 开始，每次减 1，一直减到 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| for (i = 1; i < n; i * = 2) | O(log n) | 每次乘 2 | 变量 `i` 从 1 开始，每次乘以 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| for (i = 1; i < n; i /= 2)  | O(log n) | 每次除以2 | 变量 `i` 从 $n$ 开始，每次除以 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 嵌套：for 外 n，内 n              | O(n²)    | 二重循环  | 双重嵌套循环：```for (i = 0; i < n; i++) {       // 外层跑 n 次<br>    for (j = 0; j < n; j++) {   // 内层跑 n 次<br>        // ...<br>    }<br>}<br>```                   - **执行次数：** 外层循环每跑 1 次，内层循环都要跑 $n$ 次。外层总共跑 $n$ 次。<br>    <br>- **总次数：** $n \times n = n^2$ 次。                                                                                                                                                                                                                                                       |
| 嵌套: 内层 j < i                | O(n²)    | 累加嵌套  | 它假设外层是 $O(n)$ 的):```for (i = 0; i < n; i++) {       // 外层跑 n 次 (i = 0, 1, ..., n-1)<br>    for (j = 0; j < i; j++) {   // 内层跑 i 次<br>        // ...<br>    }<br>}<br>```- **执行次数：**<br>    <br>    - 外层 $i=0$ 时，内层跑 0 次<br>        <br>    - 外层 $i=1$ 时，内层跑 1 次<br>        <br>    - 外层 $i=2$ 时，内层跑 2 次<br>        <br>    - ...<br>        <br>    - 外层 $i=n-1$ 时，内层跑 $n-1$ 次<br>        <br>- **总次数：** $0 + 1 + 2 + \dots + (n-1)$。这是一个等差数列求和，总和是 $\frac{(n-1) \times n}{2} = \frac{1}{2}n^2 - \frac{1}{2}n$。 |
#二、查找算法时间复杂度 

| 查找算法    | 最坏情况              | 说明        |
| ------- | ----------------- | --------- |
| 顺序查找    | O(n)              | 适用于无序数组   |
| 二分查找    | O(log n)          | 有序数组必须前提  |
| 哈希查找    | O(1) 平均 / O(n) 最坏 | 哈希冲突时可能退化 |
| AVL/红黑树 | O(log n)          | 平衡搜索树     |




# 选择题

##### 2-3 给定N×N×N的三维数组A，则在不改变数组的前提下，查找最小元素的时间复杂度是：
A. $O(N^2)$
B. $O(N \log N)$
C. $O(N^2 \log N)$
<span style="background:#fff88f">D.O(N^3)</span>
###### 解析：
你**不允许改变数组内容**，那么就只能进行 **线性扫描（遍历所有元素）**：
```cpp
minVal = A[0][0][0];
for (i = 0; i < N; i++)
  for (j = 0; j < N; j++)
    for (k = 0; k < N; k++)
      if (A[i][j][k] < minVal)
          minVal = A[i][j][k];
```
- 三个嵌套循环，每个从 0 到 N-1
- 总共执行：$$
N \times N \times N = N^3
$$次比较
```text
总共遍历 N³ 个元素，每个元素都访问一次：
→ 时间复杂度 = O(N³)
```


##### 2-4 For the following piece of code
```c
for(i=0; i<n; i++)
  for(j=i; j>0; j/=2)
     printf(“%d\n”, j);
```
the time complexity is:
A.$O(N\times i)$
B.$O(N)$
C.$O(N^2)$
<span style="background:#fff88f">D.O(N log N)</span>
###### **解析：**
#代码分析
<font color="#8064a2">外层循环分析</font><font color="#8064a2">：</font>
```c
for (i = 0; i < n; i++)
```
- 从 0 到 n-1，共执行 $n$ 次。
- 时间复杂度：$\mathcal{O}(n)$
<font color="#8064a2">内层循环分析:</font>
```c
for (j = i; j > 0; j /= 2)
```
- 每次将 $j$ 除以 2，直到 $j = 0$
- 执行次数为：$O(\log_2 i)$
<font color="#8064a2">总体时间复杂度推导：</font>

总体执行次数为：

$$

T(n) = \sum_{i=1}^{n-1} \log i

$$

  

> 注意：从 $i=1$ 开始，因为 $\log 0$ 无定义。

  

使用公式推导：

  

$$

\sum_{i=1}^{n} \log i = \log(n!) = \mathcal{O}(n \log n)

$$

  

所以最终时间复杂度为：

  

$$

\boxed{\mathcal{O}(n \log n)}

$$ 
####### **为什么不能直接用 $O(n) \times O(\log n)$？**

因为内层循环的时间复杂度不是恒定的 $O(\log n)$，而是随 $i$ 改变的 $O(\log i)$。

所以每一轮都不同，不能直接乘，而必须展开成求和：

$$

\sum_{i=1}^{n} \log i

$$


也就是说：
- > 如果内层和外层**无关**，可以直接乘；
    
- > 如果内层**依赖外层变量**，就必须**展开求和**
###### 数学知识补充：$\log(n!) = O(n \log n)$
阶乘定义：

$$
n! = 1 \cdot 2 \cdot 3 \cdots n
$$

取对数：

$$
\log(n!) = \log 1 + \log 2 + \cdots + \log n
$$

这是一个对数累加序列，接近于积分：

$$
\log(n!) \approx \int_1^n \log x \, dx = n \log n - n + 1 = \mathcal{O}(n \log n)
$$

所以我们可以记住：

$$
\log(n!) = \mathcal{O}(n \log n)
$$



##### 2-6 下列函数```
int func ( int n )
{   int i = 0, sum = 0;
    while ( sum < n )  sum += ++i;
    return i;
}```
的时间复杂度是：
A.$O(logn)$
<span style="background:#fff88f">B.O(n^1/2)</span>
C.$O(n)$
D.$O(nlogn)$
###### 解析：
#代码分析 
  **sum += ++i;** 
- 这是 C 语言中的<span style="background:#fdbfff">自增操作</span>：
- ++i 是 **前缀自增**：会先让 i = i + 1，再把结果参与表达式计算。
- 所以这句等价于：
```
i = i + 1;
sum = sum + i;
```
也就是说：**每次 i 加 1，然后再把 i 加到 sum 里**。直到 sum >= n，循环结束。
<font color="#8064a2">>其实就是在累加 1 到 i 的整数和</font>
$$
sum = 1 + 2 + 3 + \dots + i = \frac{i(i + 1)}{2}
$$
**关键在于循环次数的增长规律**：
循环什么时候停？
```c
while (sum < n)
```
根据公式
$$
\frac{i(i + 1)}{2} \geq n
$$

忽略低阶项，近似为：

$$
\frac{i^2}{2} \geq n \Rightarrow i^2 \geq 2n \Rightarrow i \geq \sqrt{2n}
$$

所以 `i` 大约运行到 $O(\sqrt{n})$。

##### 不同写法的sum：

| 写法          | 对应语句          | 增长速度     | 时间复杂度                    |
| ----------- | ------------- | -------- | ------------------------ |
| sum += 1    | 每次加1          | 最慢       | $\mathcal{O}(n)$         |
| sum += ++i  | 每次加 $i$（线性增长） | 中等       | $\mathcal{O}(\sqrt{n})$  |
| sum += i* i | 每次加平方         | 非常快（爆炸）  | $\mathcal{O}(n^{1/3})$ 约 |
| sum += i++  | 每次加 $i$，再自增   | 与 ++i 类似 | $O(\sqrt{n})$            |
- 快速记忆
```text
sum += 1     → O(n)
sum += ++i   → O(√n)
sum += i*i   → O(n^(1/3))
```


##### 2-20 下面程序的时间复杂度为
```c
for(i = 0; i < m; i++)
     for(j = 0; j < n; j++ )
          A[i][j] = i*j;
```
A. $O(m^2)$
B. $O(n^2)$
<span style="background:#fff88f">C. O(m * n)</span>
D. $O(m + n)$
###### 解析：
**分析过程**
* 外层循环运行次数：m
* 内层循环运行次数：n
* 每次操作 `A[i][j] = i * j` 的复杂度为 $O(1)$

所以总的执行次数为：

$$
T(m, n) = m \times n \times O(1) = O(m \cdot n)
$$

---
 **时间复杂度规律总结**

| 结构类型 | 例子 | 总体时间复杂度 |
| :--- | :--- | :--- |
| **串行结构** | 两个 for 循环分别执行 | $O(n + m)$ |
| **嵌套结构** | 一个 for 循环嵌套在另一个里 | $O(n \cdot m)$ |
| **固定次数操作** | 一条语句、赋值、常数时间操作 | $O(1)$ |


##### 2-21 三重循环：矩阵乘法

```c
for(i = 0; i < m; i++)
    for(j = 0; j < t; j++)
        c[i][j] = 0;
for(i = 0; i < m; i++)
    for(j = 0; j < t; j++)
        for(k = 0; k < n; k++)
            c[i][j] = c[i][j] + a[i][k] * b[k][j];
```

- 初始化复杂度：$O(m \times t)$
    
- 核心计算复杂度：$O(m \times t \times n)$
    

> **最终复杂度：** $\boxed{O(m × t × n)}$

###### 解析：
第一段代码：
```c
for(i = 0; i < m; i++)
    for(j = 0; j < t; j++)
        c[i][j] = 0;
```
这是**对一个 m × t 的矩阵初始化**为 0。
- 外层跑 m 次
    
- 内层跑 t 次
    
- 每次执行 O(1) 操作
所以时间复杂度是：
$$
T1 = O(m × t)
$$

第二段代码（矩阵乘法）：
```c
for(i = 0; i < m; i++)
    for(j = 0; j < t; j++)
        for(k = 0; k < n; k++)
            c[i][j] = c[i][j] + a[i][k] * b[k][j];
```
这相当于**矩阵乘法 A (m × n) × B (n × t) = C (m × t)**。
- 外层 i：m 次
    
- 中层 j：t 次
    
- 内层 k：n 次
    
每次执行一次乘法加法操作，O(1)
所以这段的时间复杂度是：
$$
T2 = O(m × t × n)
$$
综合时间复杂度：
将两个部分加起来：
$$
T = T1 + T2 = O(m × t) + O(m × t × n)
$$
但因为$O(m × t × n)$是主导项（增长更快），忽略低阶项和常数后：
><font color="#8064a2">最终时间复杂度：$O(m × t × n)$</font>,即选项A
###### **时间复杂度**：
>**时间复杂度（Time Complexity）** 是一个函数，用来衡量一个算法执行所需要的**基本操作次数**，相对于输入规模 n 的增长速度。
---

##### 2-22 死循环陷阱：

```c
i = 1; 
k = 0; 
n = 100;//<-- 关键陷阱行
do {
    k = k + 10 * i;
    i = i++;// 这行就是 i = i + 1
} while (i != n);
```
###### 解析：
 **本题陷阱：** 在这道题的代码里，**$n$ 不是一个“输入规模”**，它**不是一个变量**！
 **代码分析：**
- 第 3 行 `n = 100;` **直接把 $n$ 写死成了一个常数 100。**
    
- `do-while` 循环的条件是 `while(i != n)`，也就是 `while(i != 100)`。
    
- `i` 从 1 开始，每次 `i++`。
    
- 所以这个循环会执行 `i = 1, 2, 3, \dots, 99`。
    
- 当 `i` 变成 100 时，`100 != 100` 为 `false`，循环退出。
 **结论：**
- 这个循环**永远、固定、确定**地只会执行 **99 次**。
    
- 它的执行次数**不随任何“输入规模”的变化而变化**（因为它根本没有“输入规模”）。
    
- <span style="background:#d2cbff"> 一个执行次数为**常数**（无论是 1 次、99 次还是 1 亿次）的算法，它的时间复杂度**永远是 $O(1)$**。</span>

> **结论：** $O(1)$

---

##### 2-23 一维数组的逆置算法中，可以达到的最好空间复杂度是（ ）

<span style="background:#fff88f">A. O( 1 )</span>
B. $O(\log_2 n)$
C. $O(n)$
D. $O(n^2)$



> **空间复杂度：** $\boxed{O(1)}$

---

##### 2-24 下述程序段的时间复杂度为（）

```c
int m=100, n=200;
while(n > 0) {
    if (m > 100)
        m = -10, n--;
    else
        m++;
}
```
A. $O(mn)$
B. $O(n)$
C. $O(m)$
<span style="background:#fff88f">D. O( 1 )</span>
- **口诀：** “$n$ 是**常数**（如 `n=100`），复杂度就是 $O(1)$”。
- **口诀 2：** “$n$ 是**参数**（如 `void func(int n)`），复杂度才看 $n$”。

> **时间复杂度：** $\boxed{O(1)}$

---

##### 2-25 某算法按顺序执行程序段1和程序段2，假设程序段1的执行次数为$3n^2$，程序段2的执行次数为$0.02n^3$，则该算法的时间复杂度为（ ）

- $3n^2 + 0.02n^3$
    
- 主导项为 $n^3$
    

> **结论：** $\boxed{O(n^3)}$

---

##### 2-26 冒泡排序：

```c
for (i=0; i<n-1; i++)
    for (j=0; j<n-1-i; j++)
        swap(a[j], a[j+1]);
```

- 嵌套双重循环，总共约 $\frac{n(n-1)}{2}$ 次
    

> **复杂度：** $\boxed{O(n^2)}$

---

##### 2-27 指数增长：Let n be a non-negative integer representing the size of input. The time complexity of the following piece of code is:

```c
void func(int n){
int i = 1;
while (i <= n)
    i *= 2;
}
```
A. $O(n)$
B. $O(n^2)$
<span style="background:#fff88f">C. O(log2n)</span>
D. $O(n^{1/2})$
- **核心考点：** 循环变量 `i` **不是** 线性增加 (`i++`)，而是**指数级增加** (`i * 2`)。
- 每次乘 2：对数增长
    

> **时间复杂度：** $\boxed{O(\log_2 n)}$

---

##### 2-28 根号与立方根增长：Let $n$ be a non-negative integer representing the size of input. The time complexity of the following piece of code is:

```c
void func(int n){ 
int i = 0;
// 关键条件：i * i * i <= n
while (i*i*i <= n)
    i++;// <-- i 每次只加 1
}
```

> **复杂度：** $\boxed{O(n^{1/3})}$

### $O(\log n)$ VS $O(n^{1/3})$

你之所以会猜 $\log_3 n$，是因为你把**“循环条件”**和**“循环变量的增长方式”**搞混了。

#### 1. 真正的 $O(\log_3 n)$ 是怎样的？

- **特征：** 循环变量 `i` **自身**在**乘法**增长（`i = i * 3`）。
    
- **代码：**
```c
int i = 1;
while (i <= n) {
    i = i * 3; // <-- i 每次乘以 3
}
```
- **分析：**
    
    - `i` 的值：1, 3, 9, 27, 81, ... ( $3^k$ )
        
    - 循环**次数 $k$** 满足 $3^k \approx n$。
        
    - 根据对数定义， $k = \log_3 n$。
        
    - **口诀：** “`i` 乘以K，就是 $\log_K n$”。
#### 2. 这道题 $O(n^{1/3})$ 是怎样的？

- **特征：** 循环变量 `i` 在**加法**增长（`i++`），但是**条件**里有 `i` 的**高次幂**。
- **代码**：
```c
void func(int n) {
    int i = 0;
    // 关键条件：i * i * i <= n
    while(i * i * i <= n) 
        i++; // <-- i 每次只加 1
}
```
**分析：**

- `i` 的值：0, 1, 2, 3, 4, 5, ...
    
- 循环**条件**是 $i^3 \le n$。
    
- 循环会一直跑，直到 $i^3$ **第一次**大于 $n$ 时才停止。
    
- 设循环**次数为 $k$**（此时 $i$ 的值约等于 $k$）。
    
- 循环停止时，我们有 $k^3 \approx n$。
 **求解 $k$：**
- 如果 $k^3 = n$，那么 $k$ 等于多少？
    
- $k = \sqrt[3]{n}$ ( $n$ 的立方根)
    
- $\sqrt[3]{n}$ 用幂次表示就是 $n^{1/3}$。
    
- **结论：** 循环执行了 $k$ 次，即 $n^{1/3}$ 次。复杂度是 $O(n^{1/3})$。
---

##### 2-14 O(n) - “伪对数” 陷阱

```c
int foo(int n)
{
    int i, m = n / 2, s = 0;  // <-- 陷阱行
    for (i = 1; i <= m; ++i) // <-- 关键行
    {
        s += i;
    }
    return s;
}
```
##### 解析：为什么不是 $O(\log n)$？

**核心：** $O(\log n)$ 决定于**“循环变量 `i` 的增长方式”**，而不是**“循环终点 `m` 的计算方式”**。
###### 1. "陷阱行" `m = n / 2`

- 这一行**只在循环开始前执行 1 次**。
    
- 它的作用是**设置一个终点**。如果 $n=100$，它就算出 `m=50`。
    
- 这个 $O(1)$ 的**一次性**计算，根本不影响循环体。
###### 2. "关键行" `for (i = 1; i <= m; ++i)`

- **变量 `i` 的增长方式是什么？**
    
- 是 `++i`！
    
- `++i` 等于 `i = i + 1`。
    
- `i` 的值是：1, 2, 3, 4, 5, ... 一直加到 `m`。
    
- 这是一个**线性增长 (Linear Growth)**！
###### 3. 结论

- 循环的次数取决于 `i` 从 1 跑到 `m` 需要多少步。
    
- `i` 每次只走 1 步 (`i++`)。
    
- 所以它总共要走 `m` 步。
    
- **总执行次数 $T(n) = m$**
    
- 把 `m = n / 2` 代入：
    
- **$T(n) = n / 2$**
    
- 套用你的 **Big O 口诀：“常数当空气”**
    
- $T(n) = O(n/2) \implies O(\frac{1}{2} n) \implies$ (扔掉 $\frac{1}{2}$) $\implies O(n)$
> **复杂度：** $\boxed{O(n)}$

---

### 2-15 常数级 return 函数：

```c
int foo(int n)
{
return n * (n + 1) / 2;
}
```
##### 解析：为什么是 $O(1)$ 而不是 $O(n^2)$

你把 “算法的返回值” 和<span style="background:rgba(240, 107, 5, 0.2)"> “算法的执行次数”</span> 搞混了
###### 1. $O(n^2)$ 到底是什么？

你没记错，$O(n^2)$ 确实和 $\frac{n(n+1)}{2}$ 有关系。

但它是下面这个代码的<span style="background:rgba(240, 107, 5, 0.2)">执行次数</span>：
```c
// 这个代码的“时间复杂度”才是 O(n^2)
int sum = 0;
for (int i = 0; i < n; i++) {       // 跑 n 次
    for (int j = 0; j <= i; j++) {  // 跑 i+1 次
        sum++;                      // "sum++" 这行代码被执行了多少次？
    }
}
// 总执行次数 = 1 + 2 + 3 + ... + n = n*(n+1)/2
// T(n) = n*(n+1)/2 = 0.5n^2 + 0.5n
// 套用 Big O 口诀 "忽略低阶" + "常数当空气" => O(n^2)
```
**结论：** $O(n^2)$ 是因为一个算法**执行**了 $\frac{n(n+1)}{2}$ **次**。
###### 2. 这道题 (2-15) 的代码是什么？
```c
int foo(int n)
{
    return n * (n + 1) / 2;
}
```
**核心问题：** 这段代码里，有 `for` 循环吗？有 `while` 循环吗？有递归吗？ **答案：** **全都没有！**
###### 3. 这道题的“执行次数”是多少？

- `int foo(int n)`：函数被调用（1次）。
    
- `return n * (n + 1) / 2;`：
    
    1. `n + 1`：执行 1 次加法。
        
    2. `n * ...`：执行 1 次乘法。
        
    3. `... / 2`：执行 1 次除法。
        
    4. `return`：执行 1 次返回。
        
- **总执行次数：** 大约 4-5 次操作。
    

**最关键的问题：**

- 当 $n=10$ 时，它执行 4-5 次操作。
    
- 当 $n=1,000,000$ 时，它**仍然**只执行 4-5 次操作。
    

它的**执行次数**根本不随 $n$ 的变化而变化！

**结论：** 一个算法的执行次数是**固定的常数**（无论是 1 次还是 5 次还是 1 亿次），它的时间复杂度**永远是 $O(1)$**。


> **复杂度：** $\boxed{O(1)}$

---

## 📋 总结表格

|题号|类型|复杂度|特别说明|
|---|---|---|---|
|2-21|三重循环|$O(mnt)$|矩阵乘法|
|2-22|死循环陷阱|∞ 或 $O(1)$|`i = i++` 是陷阱|
|2-23|逆置数组|$O(1)$|空间复杂度|
|2-24|条件嵌套 while|$O(n)$|逻辑分支控制循环|
|2-25|顺序求和|$O(n^3)$|主项决定复杂度|
|2-26|冒泡排序|$O(n^2)$|双层 for|
|2-27|指数增长|$O(\log n)$|i *= 2 模式|
|2-28|根号增长|$O(n^{1/3})$|i^3 <= n 条件控制|
|2-14|单层求和|$O(n)$|n/2 与 n 同级别|
|2-15|常数计算|$O(1)$|没有循环|

---

📌 **注意点：**

- `i++` vs `++i` 的区别
    
- 判断主导项（最大项）来估算复杂度
    
- 合理使用公式和不等式来逼近循环上界