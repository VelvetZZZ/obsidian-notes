*判断题* *3 多选题 19

# 判断题

## 1-1 **NlogN² 和 NlogN 具有相同的<span style="background:#fdbfff">增长速度</span>。** T
#### **渐进时间复杂度增长速度对比**
我们来看两个函数：

-  f(n) = N log N 

-  g(n) = N log N^2 

我们可以先进行数学化简：

$$

\log N^2 = 2 \log N

$$

因此：

$$

g(n) = N \cdot \log N^2 = N \cdot 2\log N = 2N\log N

$$

可以看出：

  

$$

f(n) = N\log N,\quad g(n) = 2N\log N

$$

二者在渐进意义上具有相同的增长速度，  

都属于同一复杂度阶：

$$

\Theta(N \log N)

$$
常数因子 \( 2 \) 在大 O 表示中会被忽略。
#### 渐进时间复杂度
> **渐进时间复杂度（Asymptotic Time Complexity）**：
> 是用来衡量 **当输入规模** n **趋近于无穷大时**，
> **算法运行时间随** n **的增长趋势**。

-  **记忆口诀：
> <font color="#8064a2">“看大不看小，取快不取慢，常数当空气，低阶要忽略。”</font>
- 解读： 
| 看大不看小 | 只关心当 $n$ 很大时的表现 
| 取快不取慢 | 比较的是哪个增长得更快 
| 常数当空气 | 常数倍数在比较中可以忽略 
| 低阶要忽略 | 低阶项对增长趋势影响很小，也忽略 
-  速度快慢快速口诀记忆法
> <font color="#8064a2">口诀：常 对 线 线方 方立 指 阶</font>
- 意思是：
```

O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)

```
#####  常见时间复杂度从快到慢排序表

| 排名 | 渐进时间复杂度 | 名称 | 举例算法 |

|------|------------------|------------|----------------------------|

| ① | `O(1)` | 常数级 | 哈希表查找、直接访问 |

| ② | `O(log n)` | 对数级 | 二分查找、AVL 树查找 |

| ③ | `O(n)` | 线性级 | 顺序查找、遍历数组 |

| ④ | `O(n log n)` | 线性对数级 | 快速排序、归并排序、堆排序 |

| ⑤ | `O(n²)` | 平方级 | 冒泡排序、插入排序 |

| ⑥ | `O(n³)` | 立方级 | 三重循环、Floyd算法 |

| ⑦ | `O(2ⁿ)` | 指数级 | 回溯法、子集生成 |

| ⑧ | `O(n!)` | 阶乘级 | 全排列、旅行商问题 |

##### 🔍 判断谁更快的技巧

1. 比较主项的“增长率”大小

2. 忽略常数因子和低阶项

3. 指数、阶乘是最慢的，能避免尽量避免！

---

###### ✨ 图像理解（增长趋势）

随着 `n` 的增大：

```

O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)

```

---

###### 应试小练习


1. `O(n log n)` vs `O(n²)` → ✅ `O(n log n)` 更快

2. `O(2ⁿ)` vs `O(n!)` → ✅ `O(2ⁿ)` 更快

3. `O(1)` vs `O(log n)` → ✅ `O(1)` 更快

---
> 记住：**渐进复杂度是“长期跑步谁更慢”的比较！**
---

## 1-3 对于某些算法，随着问题规模的扩大，所花的时间不一定<span style="background:#fdbfff">单调增加</span>。T
#### **<font color="#c0504d"> 对算法运行时间随输入规模增长变化趋势的理解</font>**
##### 大多数时候我们说“输入规模越大，运行时间越长”——这说的是**渐进意义上的时间复杂度**。但在**实际运行中**，**时间并不总是单调递增**，原因包括：

> **1.** 某些输入会触发更快的路径
> 例如：快速排序（Quick Sort）在某些特殊输入下比其他情况运行得更快或更慢；或者算法中有某种优化，例如提前终止（early stopping）。
> **2.** 缓存优化、内存对齐等系统层面影响
> 当数据量增大但正好被缓存优化、命中CPU cache，反而运行时间会降低。
> **3.** 分支选择不同，导致执行路径变化
> 输入不同会导致程序选择不同的分支，比如循环提前跳出、条件判断不满足等、运行时间差异很大。
> **4.** 最欢情况 **≠** 实际情况
> - 例如二分查找的最坏情况是 O(\log n)，但某些情况一开始就找到目标，实际只用了 1 步。
##### **结论总结：**
- **“非单调”= 时间曲线可能会上下起伏。**
- “算法实际运行时间 ≠ 理论时间复杂度（渐进上界）”
- <font color="#8064a2">渐进时间复杂度是对**最坏情况的估计**。</font>
- 实际运行中，**不一定输入变大就花更多时间**。
- 所以这道题说“**不一定单调增加**”是对的。


## 1-6 Let n be a non-negative integer representing the size of input. The time complexity of the following piece of code is O(n).      T

- 设 n 是一个**非负整数**，表示**输入的规模**，- 下面这段代码的时间复杂度是 O(n)   ✅
```
int func(int n){
    int sum = 0;
        for(int i = n; i > 0; i /= 2)
            for(int j = 0; j < i; j++)
                sum++;
    return sum;
}

```

#### <span style="background:rgba(92, 92, 92, 0.2)">本题解析</span>
#####  1. 拆解循环

- **外层循环：** `for(int i = n; i > 0; i /= 2)`
    
    - `i` 的值**不是** $n, n-1, n-2, \dots$
        
    - `i` 的值是 $n, n/2, n/4, n/8, \dots, 1$ (每次都减半)
        
    - 这是一个 **$O(\log n)$** 次的循环。
        
- **内层循环：** `for(int j = 0; j < i; j++)`
    
    - 它每次执行 **`i`** 次。
        

##### 2. 核心：求和 (Summing the Work)

`sum++` 的总执行次数 $T(n)$ 是**每一次**内循环执行次数的总和：

- 外层 `i = n` 时， 内层执行 **$n$** 次
    
- 外层 `i = n/2` 时， 内层执行 **$n/2$** 次
    
- 外层 `i = n/4` 时， 内层执行 **$n/4$** 次
    
- ...
    
- 外层 `i = 1` 时， 内层执行 **$1$** 次
    

所以，总执行次数 $T(n) = n + \frac{n}{2} + \frac{n}{4} + \frac{n}{8} + \dots + 1$

##### 3. 计算总和

这是一个等比数列求和 (Geometric Series)。

$T(n) = n + \frac{n}{2} + \frac{n}{4} + \dots + 1$

我们把这个数列反过来写：

$T(n) = 1 + 2 + 4 + 8 + \dots + \frac{n}{2} + n$

根据等比数列求和公式，这个和约等于最后一项 $n$ 的两倍，即 $2n - 1$。

（你也可以把 $n$ 提出来：$T(n) = n \times (1 + \frac{1}{2} + \frac{1}{4} + \dots)$，括号内的和无限趋近于 2）

所以，总执行次数 $T(n) \approx 2n$。

##### 本题型：减半 + 遍历

for (i = n; i > 0; i /= 2)

    for (j = 0; j < i; j++)  → O(n)
#### <font color="#c0504d">分析“变动内循环”的时间复杂度</font>

#一、基础循环复杂度模式表

| 代码结构                        | 时间复杂度    | 快速识别  | 具体含义                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| --------------------------- | -------- | ----- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| for (i = 0; i < n; i++)     | O(n)     | 线性增长  | 变量 `i` 从 0 开始，每次加 1，一直加到 $n-1$ (因为 $i < n$)                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| for (i = 0; i < n; i+=k)    | O(n)     | 步长为常数 | 变量 `i` 从 0 开始，每次加 `k` (比如 0, 3, 6, 9...)，直到 `i` 不再小于 $n$。                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| for(i = n; i > 0; i--)      | O(n)     | 倒序遍历  | 变量 `i` 从 $n$ 开始，每次减 1，一直减到 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| for (i = 1; i < n; i * = 2) | O(log n) | 每次乘 2 | 变量 `i` 从 1 开始，每次乘以 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| for (i = 1; i < n; i /= 2)  | O(log n) | 每次除以2 | 变量 `i` 从 $n$ 开始，每次除以 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 嵌套：for 外 n，内 n              | O(n²)    | 二重循环  | 双重嵌套循环：```for (i = 0; i < n; i++) {       // 外层跑 n 次<br>    for (j = 0; j < n; j++) {   // 内层跑 n 次<br>        // ...<br>    }<br>}<br>```                   - **执行次数：** 外层循环每跑 1 次，内层循环都要跑 $n$ 次。外层总共跑 $n$ 次。<br>    <br>- **总次数：** $n \times n = n^2$ 次。                                                                                                                                                                                                                                                       |
| 嵌套: 内层 j < i                | O(n²)    | 累加嵌套  | 它假设外层是 $O(n)$ 的):```for (i = 0; i < n; i++) {       // 外层跑 n 次 (i = 0, 1, ..., n-1)<br>    for (j = 0; j < i; j++) {   // 内层跑 i 次<br>        // ...<br>    }<br>}<br>```- **执行次数：**<br>    <br>    - 外层 $i=0$ 时，内层跑 0 次<br>        <br>    - 外层 $i=1$ 时，内层跑 1 次<br>        <br>    - 外层 $i=2$ 时，内层跑 2 次<br>        <br>    - ...<br>        <br>    - 外层 $i=n-1$ 时，内层跑 $n-1$ 次<br>        <br>- **总次数：** $0 + 1 + 2 + \dots + (n-1)$。这是一个等差数列求和，总和是 $\frac{(n-1) \times n}{2} = \frac{1}{2}n^2 - \frac{1}{2}n$。 |
#二、查找算法时间复杂度 

| 查找算法    | 最坏情况              | 说明        |
| ------- | ----------------- | --------- |
| 顺序查找    | O(n)              | 适用于无序数组   |
| 二分查找    | O(log n)          | 有序数组必须前提  |
| 哈希查找    | O(1) 平均 / O(n) 最坏 | 哈希冲突时可能退化 |
| AVL/红黑树 | O(log n)          | 平衡搜索树     |




# 选择题

##### 2-3 给定N×N×N的三维数组A，则在不改变数组的前提下，查找最小元素的时间复杂度是：
A. $O(N^2)$
B. $O(N \log N)$
C. $O(N^2 \log N)$
<span style="background:#fff88f">D.O(N^3)</span>
###### 解析：
你**不允许改变数组内容**，那么就只能进行 **线性扫描（遍历所有元素）**：
```cpp
minVal = A[0][0][0];
for (i = 0; i < N; i++)
  for (j = 0; j < N; j++)
    for (k = 0; k < N; k++)
      if (A[i][j][k] < minVal)
          minVal = A[i][j][k];
```
- 三个嵌套循环，每个从 0 到 N-1
- 总共执行：$$
N \times N \times N = N^3
$$次比较
```text
总共遍历 N³ 个元素，每个元素都访问一次：
→ 时间复杂度 = O(N³)
```


##### 2-4 For the following piece of code
```c
for(i=0; i<n; i++)
  for(j=i; j>0; j/=2)
     printf(“%d\n”, j);
```
the time complexity is:
A.$O(N\times i)$
B.$O(N)$
C.$O(N^2)$
<span style="background:#fff88f">D.O(N log N)</span>
###### **解析：**
#代码分析
<font color="#8064a2">外层循环分析</font><font color="#8064a2">：</font>
```c
for (i = 0; i < n; i++)
```
- 从 0 到 n-1，共执行 $n$ 次。
- 时间复杂度：$\mathcal{O}(n)$
<font color="#8064a2">内层循环分析:</font>
```c
for (j = i; j > 0; j /= 2)
```
- 每次将 $j$ 除以 2，直到 $j = 0$
- 执行次数为：$O(\log_2 i)$
<font color="#8064a2">总体时间复杂度推导：</font>

总体执行次数为：

$$

T(n) = \sum_{i=1}^{n-1} \log i

$$

  

> 注意：从 $i=1$ 开始，因为 $\log 0$ 无定义。

  

使用公式推导：

  

$$

\sum_{i=1}^{n} \log i = \log(n!) = \mathcal{O}(n \log n)

$$

  

所以最终时间复杂度为：

  

$$

\boxed{\mathcal{O}(n \log n)}

$$ 
####### **为什么不能直接用 $O(n) \times O(\log n)$？**

  

因为内层循环的时间复杂度不是恒定的 $O(\log n)$，而是随 $i$ 改变的 $O(\log i)$。

所以每一轮都不同，不能直接乘，而必须展开成求和：

  

$$

\sum_{i=1}^{n} \log i

$$

  

也就是说：

  

- > 如果内层和外层**无关**，可以直接乘；
    
- > 如果内层**依赖外层变量**，就必须**展开求和**
###### 数学知识补充：$\log(n!) = O(n \log n)$
阶乘定义：

$$
n! = 1 \cdot 2 \cdot 3 \cdots n
$$

取对数：

$$
\log(n!) = \log 1 + \log 2 + \cdots + \log n
$$

这是一个对数累加序列，接近于积分：

$$
\log(n!) \approx \int_1^n \log x \, dx = n \log n - n + 1 = \mathcal{O}(n \log n)
$$

所以我们可以记住：

$$
\log(n!) = \mathcal{O}(n \log n)
$$
