#数据结构基础 #概念
## 判断题
### 1-2 算法分析的两个主要方面是时间复杂度和空间复杂度的分析。T

### 1-4 <font color="#8064a2">抽象数据类型</font>中<font color="#b2a2c7">基本操作</font>的<span style="background:rgba(92, 92, 92, 0.2)"><font color="#000000">定义</font></span>与<span style="background:#d2cbff">具体实现</span>有关。<font color="#ff0000"> F</font>
##### <font color="#ff0000">抽象数据类型 (ADT)</font>
**抽象数据类型 (Abstract Data Type, ADT)** 是一个<span style="background:rgba(255, 183, 139, 0.55)">数学模型</span>，它定义了一个<span style="background:rgba(255, 183, 139, 0.55)">数据集</span>以及在该数据集上的一组<span style="background:rgba(255, 183, 139, 0.55)">操作</span>。
>这个定义包含三个核心要素：
>1. **数据对象 (Data Object)：** 数据的集合（比如，一个“栈”是0个或多个元素的序列）。
>2. **数据关系 (Data Relationship)：** 数据元素之间的逻辑关系（比如，“栈”具有“后进先出 LIFO”的逻辑关系）。
>3. **基本操作 (Basic Operations)：** 对数据对象施加的一组操作（比如，“栈”有 `Push`, `Pop`, `IsEmpty`）。
###### <span style="background:rgba(74, 82, 199, 0.2)">操作的定义</span>
只描述了该操作<font color="#8064a2">“做什么“ </font>。
e.g
- **操作名：** `Pop()`
- **输入 (Preconditions)：** 调用它之前，“栈”必须是非空的。
- **输出 (Postconditions)：** 调用它之后，“栈”的栈顶元素被移除，并返回该元素。
**这个定义是“抽象”的、“逻辑”的。** 它不关心底层发生了什么。
###### <span style="background:rgba(74, 82, 199, 0.2)">操作的实现</span>
描述了该操作<font color="#8064a2">“如何做”</font>。
e.g
- **实现A (顺序栈)：**
	- `Pop()` 可能是：`return array[top--];`
	- 这是一个**数组**操作，时间复杂度是 $O(1)$。
- **实现B (链栈)：**
    - `Pop()` 可能是：`temp = top; data = top->data; top = top->next; free(temp); return data;`
    - 这是一个**链表**操作，时间复杂度也是 $O(1)$
###### 为什么“定义”与“实现”必须无关？
**“封装”** 的目的就是建立一道“防火墙”。
- 对用户 (Client) 而言：
    用户（调用 ADT 的人）只被允许看到“操作的定义”（接口）。用户不需要，也不应该知道底层是用数组还是链表。这使得用户代码更简洁、更安全。
- 对实现者 (Implementer) 而言：
    实现者（编写 ADT 的人）可以自由地更换内部实现。比如，我可以把 $O(n)$ 的数组实现换成 $O(1)$ 的链表实现，而不需要通知用户更改任何代码，因为**“定义” (接口) 没有变**。

结论：
<span style="background:rgba(136, 49, 204, 0.2)">ADT 的定义是其逻辑属性，而实现是其物理属性。</span>ADT 的存在价值就是将两者解耦 (Decouple)。因此，“定义”绝不依赖于“实现”。

### 1-5 算法可以没有输入，但是必须有输出。T
##### <span style="background:rgba(240, 167, 216, 0.55)">考点：算法的基本特性</span>
    1.有穷性 (Finiteness)：必须在有限步骤内结束。
    2.确定性 (Determinism)：每一步都有确切的含义，没有歧义。
    3.可行性 (Feasibility)：每一步都能通过有限次数的运算完成。
    4.输入 (Input)：具有**零个或多个**外部输入。
    5.输出 (Output)：具有**一个或多个**输出。
**结论：** 一个算法可以不需要外界给它原料（没有输入），但它必须产生一个产品（有输出）。否则，这个“算法”就是一条没有意义的“废弃生产线”。

### 2-1 下面的程序段违反了算法的（）原则。
```c
void sam()
{  int n=2;
   while (n%2==0)    n+=2;
   printf(“%d”,n);
}
```
<span style="background:#fff88f">A.有穷性</span>
B.确定性
<span style="background:#d2cbff">C.可行性（混淆项）</span>
D.健壮性
###### 解析

- **有穷性定义：** 算法必须在执行<span style="background:#b1ffff">有限的步骤</span>之后自动结束，而不能是无限的。
- **健壮性定义：** 算法对<span style="background:#b1ffff">非法输入</span>应能做出适当反应，而不是崩溃（比如 `1/0`）。这题没有输入，所以 D 不对。
- **确定性定义：** 每一步都<span style="background:#b1ffff">没有歧义</span>（比如 `i = i++` 就有歧义）。这题每一步都很明确，所以 B 不对。
- **可行性定义：** <span style="background:#d2cbff">每一步都能执行</span>（比如 `1/0` 就不可行）。这题每一步都能执行，所以 C 不对。
###### 有穷性和可行性的区别：
 1. 有穷性 (Finiteness)：指向“整个算法”
- **定义：** 指<span style="background:rgba(255, 183, 139, 0.55)">整个算法</span>的<span style="background:rgba(136, 49, 204, 0.2)"><font color="#000000">总步骤数</font></span>必须是有限的。
- **人话：** <span style="background:#b1ffff">算法必须会停</span>。
1. 可行性 (Feasibility)：指向“算法的每一步”
- **定义：** 指算法中的<span style="background:rgba(136, 49, 204, 0.2)">每一个单独的步骤</span>都必须是能被（人或机器）在<span style="background:rgba(255, 183, 139, 0.55)">有限时间</span>内<span style="background:#d2cbff">执行并完成</span>的。
- **人话：** <span style="background:#b1ffff">写的每一行代码，电脑都必须能算</span>，不能让电脑“死机”或“懵掉”。

### 2-7 数据的基本单位是（）
<span style="background:#fff88f">A.数据元素</span>
B.文件
C.数据项
D.数据结构
##### 解析：
- “<span style="background:rgba(255, 183, 139, 0.55)">数据结构</span>**”是 “<span style="background:rgba(240, 167, 216, 0.55)">数据元素</span>**” 的集合。

- “<span style="background:rgba(240, 167, 216, 0.55)">数据元素</span>”是 “<span style="background:rgba(205, 244, 105, 0.55)">数据项</span>” 的集合。

- **数据的“基本单位”**（我们操作的那个“东西”）是 <span style="background:rgba(240, 167, 216, 0.55)">A. 数据元素</span>。

- **数据的“最小单位”**（不可再分的）是 <span style="background:rgba(205, 244, 105, 0.55)">C. 数据项</span>。

### 2-8 数据的（）包括集合、线性结构、树形结构和图形结构四种基本类型。
A.存储结构
<span style="background:#fff88f">B.逻辑结构</span>
C.基本运算
D.算法描述
##### <font color="#d83931">逻辑结构 (Logical Structure)</font>
**定义：** 指数据元素之间**“<span style="background:rgba(240, 107, 5, 0.2)">抽象的</span>”、“<span style="background:rgba(240, 107, 5, 0.2)">概念上</span><span style="background:rgba(240, 107, 5, 0.2)">的</span>”关系**。它与数据在电脑里“怎么存”**无关**。
**人话：** “这堆数据在**理论上**长什么样？”
**分类：** 
1. <span style="background:rgba(136, 49, 204, 0.2)">集合 (Set)</span>： 元素之间<font color="#d83931">没关系</font>，就是“同属一个集合”。
2. <span style="background:rgba(136, 49, 204, 0.2)">线性结构 (Linear)</span>： 元素之间“<font color="#d83931">一对一</font>”**（比如排队）。
3. <span style="background:rgba(136, 49, 204, 0.2)">树形结构 (Tree</span><span style="background:rgba(136, 49, 204, 0.2)">)</span>： 元素之间“<font color="#d83931">一对多</font>”**（比如家族树）。
4. <span style="background:rgba(136, 49, 204, 0.2)">图形结构 (Graph)</span>： 元素之间“<font color="#d83931">多对多</font>”**（比如社交网络）。
##### <font color="#d83931">存储结构 (Storage Structure)</font>
- **定义：** 指数据的**逻辑结构**在**计算机内存中**的**“具体实现方式”**。
- **人话：** “这堆数据在**电脑里**要怎么存？”
- **分类：** 
1. <span style="background:rgba(240, 167, 216, 0.55)">顺序存储 (Sequential)</span>： 用一块**连续的**内存来存（比如**数组 Array**）。
2. <span style="background:rgba(240, 167, 216, 0.55)">链式存储 (Linked)：</span> 用**指针 (pointer)** 把**零散的**内存块串起来（比如**链表 Linked List**）。
 - 一句话总结：<span style="background:rgba(255, 183, 139, 0.55)">逻辑结构（线性、树...）是目的。存储结构（数组、链表...）是手段。</span>
### 2-11 下列关于数据的逻辑结构的叙述中，（）是正确的。

<span style="background:#fff88f">A.数据的逻辑结构是数据元素间关系的描述</span>

B.数据的逻辑结构反映了数据在计算机中的存储方式

C.数据的逻辑结构分为顺序结构和链式结构

D.数据的逻辑结构分为<span style="background:#ff4d4f">静态结构和动态结构</span >
/改对：<font color="#8064a2">从<span style="background:rgba(240, 167, 216, 0.55)">内存分配方式</span>的角度，数据结构可以分为静态结构和动态结构。</font>
##### <font color="#d83931">静态结构 vs 动态结构</font>

- 这个分类是从<span style="background:rgba(240, 167, 216, 0.55)">"内存管理"</span>的角度来看的，它描述的是一个数据结构在程序<span style="background:rgba(240, 167, 216, 0.55)">运行时</span>，它的大小（占用的内存）是否可以<span style="background:rgba(136, 49, 204, 0.2)">改变</span>。
###### 1. 静态结构 (Static Structure)
- **定义：** 指数据结构的<span style="background:#d2cbff">大小在编译时就已经确定</span>，一旦分配了内存，其<span style="background:#d2cbff">大小在程序运行期间就不能再改变</span>。
- **人话：** “一次性给够，不许多也不能少”。
- **典型代表：** **数组 (Array)**。
    
    - 当你在 C 语言里写 `int arr[100];` 时，编译器（或操作系统）会**立刻**为你分配 100 个 `int` 的**连续空间**。
        
    - 在程序运行时，你**不能**让这个 `arr` 变成 101 个或 99 个。它的大小被“锁死”了。
        
- **优点：** 访问速度快（因为是连续内存），管理简单。
- **缺点：** **不够灵活**。你必须提前猜好需要多大空间，猜大了浪费，猜小了就溢出 (Overflow)。
###### 2. 动态结构 (Dynamic Structure)
- **定义：** 指数据结构的大小可以<span style="background:#d2cbff">在程序运行期间根据需要“动态地”增加或缩小</span>。
- **人话：** “用多少，拿多少，不够了再要”。
- **典型代表：** **链表 (Linked List)**、**树 (Tree)**。
    
    - 它们通常使用**指针**来管理内存。
        
    - 当你需要添加一个新元素时，你才去“动态申请” (e.g., `malloc` 或 `new`) 一块新内存（一个新节点），然后用指针把它“挂”到结构上。
        
    - 当你删除一个元素时，你可以“释放” (e.g., `free` 或 `delete`) 它占用的内存。
    
- **优点：** **非常灵活**，不浪费空间，理论上可以无限增长（只要你内存够）。
- **缺点：** 访问速度可能较慢（因为内存不连续），管理略微复杂（要处理指针）。
### 2-12 算法分析的目的是（）

A.找出数据结构的合理性

B.研究算法中的输入和输出的关系

<span style="background:#fff88f">C.分析算法的效率以求改进</span>

D.分析算法的易懂性和文档性

### 2-13 数据结构是一门研究非数值计算的程序设计问题中计算机的（）以及它们之间的关系和运算等的学科。

<span style="background:#fff88f">A.操作对象</span>

B.计算方法

C.逻辑存储

D.数据映象

### 2-14 数据结构形式地定义为（K，R），其中K是（）的有限集合，R是K上的关系上的有限集合。

A.算法

<span style="background:#fff88f">B.数据元素</span>

C.数据操作

D.逻辑结构
##### <font color="#d83931">数据结构的二元组定义</font>
> (K, R) 是什么？
    这是数据结构的**“形式化定义”**（Formal Definition），它试图用数学的语言来描述“结构”。
###### 1.K = 数据元素 (Data Element) - (✅ 本题答案)
- **定义：** `K` 是**所有“数据元素”**的**集合**。
- **人话：** `K` 就是你**所有“东西”**的合集。
    
- **例子（图 Graph）：** 假设你有一个图，`K` 就是**所有“顶点” (Vertex)** 的集合。
    - `K = {V1, V2, V3, V4}`
        
- **例子（线性表 Linear List）：** `K` 就是**所有“记录”**的集合。
    - `K = {张三, 李四, 王五}`
###### 2. R = 关系 (Relation)
- **定义：** `R` 是定义在 `K` 上的**“关系”**的集合。
- **人话：** `R` 就是你这堆“东西”的**“组织方式”**或**“连接规则”**。
    
- **例子（图 Graph）：** `R` 就是**所有“边” (Edge)** 的集合。
    - `R = {(V1, V2), (V2, V3), (V1, V3)}` (表示V1和V2有连接, V2和V3有连接...)
        
- **例子（线性表 Linear List）：** `R` 就是一个**“序对”**关系。
    
    - `R = {<张三, 李四>, <李四, 王五>}` (表示张三在李四前面, 李四在王五前面)

### 2-15 在数据结构中，与所使用的计算机无关的数据结构是（）。

<span style="background:#fff88f">A.逻辑结构</span>

B.存储结构

C.逻辑结构和存储结构

D.物理结构

### 2-17 线性结构中元素之间存在（）关系。
<span style="background:#fff88f">A.一对一</span>
B.一对多 ---------树结构
C.多对多 ---------图结构
D.多对一 ---------干扰项

##### <font color="#d83931">逻辑结构四大关系认定</font>

 1. <font color="#d83931">线性结构 (Linear Structure)</font> - <span style="background:rgba(255, 183, 139, 0.55)">“一对一”</span>
- **定义：** 它的元素就像“排队”**。
- **关系：** 队伍中的任何一个元素（除了第一个和最后一个），都有且仅有一个“前驱”（前面那个人）和有且仅有一个“后继”（后面那个人）。
    
- **结论：** 这种关系就是“一对一”。
    
- **例子：** 数组、链表、栈、队列。

2. <font color="#d83931"> 树形结构 (Tree Structure)</font> - <span style="background:rgba(255, 183, 139, 0.55)">“一对多”</span>
- **定义：** 它的元素就像**“家族树”**。
- **关系：** 任何一个“父节点”（父亲）可以有多个“子节点”（孩子）。
    
- **结论：** 这种关系就是“一对多”**。

3. <font color="#d83931">图形结构 (Graph Structure)</font> - <span style="background:rgba(255, 183, 139, 0.55)">“多对多”</span>
- **定义：** 它的元素就像**“社交网络”**。
- **关系：** 任何一个“节点”（人）都可以和多个其他“节点”（人）有关系（互粉）。
    
- **结论：** 这种关系就是“多对多”**。

## Code Completion

### 6-1 递归求Fabonacci数列
```c
int f(int n){
	if(n == 0)return 0;
	if(n == 1)return 1;
	return f(n - 1)+ f(n - 2);
}
```